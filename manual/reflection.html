<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>19 Reflection</title>

<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" />

</head>

<body>

<div id="doc_content">


<h1><a name="intro"></a>19 Reflection</h1>

<p class="paragraph">The reflection library contains convenient classes to reflect on AS3 classes,
methods and properties without the need for cumbersome parsing of XML output from 
<code>describeType</code>.</p>
<h2><a name="basics"></a>19.1  The basics</h2>

<p class="paragraph">We will use the <code>flash.geom.Point</code> class from the core Player API to illustrate
the features of the Spicelib Reflection API. The following listing shows the output of
the <code>flash.utils.describeType</code> method if invoked with <code>Point</code> as the parameter:</p>

<pre><code>&lt;type name="flash.geom::Point" base="Class" isDynamic="true" isFinal="true" isStatic="true"&gt;
  &lt;extendsClass type="Class"/&gt;
  &lt;extendsClass type="Object"/&gt;
  &lt;method name="interpolate" declaredBy="flash.geom::Point" returnType="flash.geom::Point"&gt;
    &lt;parameter index="1" type="flash.geom::Point" optional="false"/&gt;
    &lt;parameter index="2" type="flash.geom::Point" optional="false"/&gt;
    &lt;parameter index="3" type="Number" optional="false"/&gt;
  &lt;/method&gt;
  &lt;method name="polar" declaredBy="flash.geom::Point" returnType="flash.geom::Point"&gt;
    &lt;parameter index="1" type="Number" optional="false"/&gt;
    &lt;parameter index="2" type="Number" optional="false"/&gt;
  &lt;/method&gt;
  &lt;method name="distance" declaredBy="flash.geom::Point" returnType="Number"&gt;
    &lt;parameter index="1" type="flash.geom::Point" optional="false"/&gt;
    &lt;parameter index="2" type="flash.geom::Point" optional="false"/&gt;
  &lt;/method&gt;
  &lt;accessor name="prototype" access="readonly" type="*" declaredBy="Class"/&gt;
  &lt;factory type="flash.geom::Point"&gt;
    &lt;extendsClass type="Object"/&gt;
    &lt;constructor&gt;
      &lt;parameter index="1" type="Number" optional="true"/&gt;
      &lt;parameter index="2" type="Number" optional="true"/&gt;
    &lt;/constructor&gt;
    &lt;method name="subtract" declaredBy="flash.geom::Point" returnType="flash.geom::Point"&gt;
      &lt;parameter index="1" type="flash.geom::Point" optional="false"/&gt;
    &lt;/method&gt;
    &lt;method name="normalize" declaredBy="flash.geom::Point" returnType="void"&gt;
      &lt;parameter index="1" type="Number" optional="false"/&gt;
    &lt;/method&gt;
    &lt;method name="toString" declaredBy="flash.geom::Point" returnType="String"/&gt;
    &lt;method name="clone" declaredBy="flash.geom::Point" returnType="flash.geom::Point"/&gt;
    &lt;method name="offset" declaredBy="flash.geom::Point" returnType="void"&gt;
      &lt;parameter index="1" type="Number" optional="false"/&gt;
      &lt;parameter index="2" type="Number" optional="false"/&gt;
    &lt;/method&gt;
    &lt;accessor name="length" access="readonly" type="Number" declaredBy="flash.geom::Point"/&gt;
    &lt;method name="equals" declaredBy="flash.geom::Point" returnType="Boolean"&gt;
      &lt;parameter index="1" type="flash.geom::Point" optional="false"/&gt;
    &lt;/method&gt;
    &lt;variable name="y" type="Number"/&gt;
    &lt;method name="add" declaredBy="flash.geom::Point" returnType="flash.geom::Point"&gt;
      &lt;parameter index="1" type="flash.geom::Point" optional="false"/&gt;
    &lt;/method&gt;
    &lt;variable name="x" type="Number"/&gt;
  &lt;/factory&gt;
&lt;/type&gt;
</code></pre>

As you see you get information about superclasses, properties (<code>&lt;accessor&gt;</code> and 
<code>&lt;variable&gt;</code> tags), the constructor and methods and their parameter types. The Spicelib
Reflection API builds on top of the output generated by <code>describeType</code> and offers the
following features:

<ul>
<li> A convenient API to retrieve that information without the need to parse XML. </li>
<li> A central cache so that invocations of <code>describeType</code> and XML parsing occur only once
for each class. </li>
<li> A central repository to register <code>Converter</code> instances for any number of target types. </li>
<li> Methods to reflectively set properties and invoke methods of instances while using the registered
converters to automatically convert method parameters and property values if their type does not match
the required type. </li>
<li> The option to register custom classes to represent metadata tags to offer a type-safe way
to reflect on metadata tags and its attributes. </li>
</ul>

<p class="paragraph">The following sections will explain each of these features.</p>


<p class="subheadline"> Performance Improvements in Flash Player 10.1 and Higher </p>

<p class="paragraph">When using Flash Player 10.1 or newer the library supports
the new <code>describeTypeJSON</code> function under the hood which is up to 4 times
faster than the old XML-based <code>describeType</code>. It automatically detects
the availability of this function without the need for a configuration step.
The same SWC can be used in all versions of Flash Player 9 to 11.</p>
<h2><a name="classinfo"></a>19.2 Obtaining ClassInfo instances</h2>

<p class="paragraph">The <code>ClassInfo</code> class is the central entry point for all reflection features. 
We chose the name ClassInfo as the name Class is already a top level type in AS3.
There are three ways to obtain an instance of <code>ClassInfo</code>:</p>

<table>
<tr><td> By class name </td><td> Example: <code>ClassInfo.forName("flash.geom.Point");</code> </td></tr>
<tr><td> By class reference </td><td> Example: <code>ClassInfo.forClass(Point);</code> </td></tr>
<tr><td> By instance </td><td> Example: <code>ClassInfo.forInstance(new Point());</code> </td></tr>
</table>

<p class="paragraph">Of course the last example would only make sense if you use an existing instance of a class
and don't know or don't want to determine the type of the instance first. Otherwise the second
example is the most efficient. If you invoke one of the above three static methods more than
once for the same type, the returned <code>ClassInfo</code> instance will be taken from the internal
cache to avoid the overhead of parsing the XML returned by <code>describeType</code> again.</p>

<p class="paragraph">The <code>ClassInfo</code> class offers methods to obtain the superclasses and implemented interfaces
(<code>getSuperclasses</code> and <code>getInterfaces</code>) and the <code>isType</code> method that checks if 
the specified parameter is a superclass or one of the implemented interfaces of the class represented
by the <code>ClassInfo</code> instance.</p>

<p class="paragraph">Furhermore the <code>ClassInfo</code> class contains methods to reflect on properties and methods
which will be explained in the following sections, 
but before that we will introduce the concept of automatic type conversion, as this concept is used
internally for some of the reflection features related to properties and methods.</p>
<h2><a name="conversion"></a>19.3 Automatic type conversion</h2>

<p class="paragraph">The <code>Converters</code> class of the <code>org.spicefactory.lib.reflect</code> package includes a static
<code>addConverter</code> method. This allows to register <code>Converter</code> instances and map them to
particular types. Internally the Reflection Module will use these Converters to automatically convert
method parameters and property values if their type does not match the required type. This applies
to <code>Property.setValue</code>, <code>Method.invoke</code> and <code>Constructor.newInstance</code>, 
all of them explained in the following sections. They will also be used to convert attributes
of custom metadata tags to the properties of any registered custom metadata class.
The Reflection Module contains some builtin Converters for basic types like <code>Boolean</code>,
<code>String</code>, <code>int</code>, etc., but you can easily add your own. Just implement the
<code>Converter</code> interface and add it to the Reflection Module with <code>Converters.addConverter</code>.</p>
<h2><a name="properties"></a>19.4 Reflecting on properties</h2>

<p class="paragraph">The <code>Property</code> class allows to obtain information about the type of the property and
if it is readable and writable:</p>

<pre><code>var ci:ClassInfo = ClassInfo.forClass(Point);
var p:Property = ci.getProperty("x");
trace("type:     " + p.type.name);
trace("readable: " + p.readable);
trace("writable: " + p.writable);
</code></pre>

<p class="paragraph">The output for the code above would be:</p>

<pre><code>type:     Number
readable: true
writable: true
</code></pre>

<p class="paragraph">Furthermore you can also use the <code>Property</code> class to read and write the value
of that property from/to a particular instance of the class that property belongs to:</p>

<pre><code>var point:Point = new Point(7, 5);
var ci:ClassInfo = ClassInfo.forClass(Point);
var p:Property = ci.getProperty("x");
p.setValue(point, 12);
trace(point.x); // output: 12
</code></pre>

<p class="paragraph">When using <code>Property.setValue</code> any necessary type conversion will be done as described
in <a href="reflection.php#conversion">19.3&nbsp;Automatic type conversion</a>.</p>

<p class="paragraph">Reading and writing property values reflectively is usually not done in application code.
It is most useful for developing frameworks and libraries that have to manage classes not known
until runtime.</p>
<h2><a name="methods"></a>19.5 Reflecting on methods</h2>

<p class="paragraph">The <code>Method</code> class allows to obtain information about the method parameter types and
if they are optional or not:</p>

<pre><code>var ci:ClassInfo = ClassInfo.forClass(Point);
var m:Method = ci.getMethod("add");
var params:Array = m.parameters;
trace("param count: " + params.length);
var param:Parameter = params[0] as Parameter;
trace("param type: " + param.type.name);
trace("param required: " + param.required);
trace("return type: " + m.returnType.name);
</code></pre>

<p class="paragraph">The output for the code above would be:</p>

<pre><code>param count: 1
param type: flash.geom::Point
param required: true
return type: flash.geom::Point
</code></pre>

<p class="paragraph">Furthermore you can also use the <code>Method</code> class to reflectively invoke
the method on a particular instance of the class that the <code>Method</code> instance belongs to:</p>

<pre><code>var point:Point = new Point(7, 5);
var ci:ClassInfo = ClassInfo.forClass(Point);
var m:Method = ci.getMethod("add");
var result:Point = m.invoke(point, [new Point(3, 3)]);
trace(result.x); // output: 10
</code></pre>

<p class="paragraph">When using <code>Method.invoke</code> any necessary type conversion for the method parameters
will be done as described in <a href="reflection.php#conversion">19.3&nbsp;Automatic type conversion</a>.</p>

<p class="paragraph">Reflectively invoking methods is usually not done in application code.
It is most useful for developing frameworks and libraries that have to manage classes not known
until runtime.</p>
<h2><a name="constructors"></a>19.6 Reflecting on constructors</h2>

<p class="paragraph">The <code>Constructor</code> class allows to obtain information about the method parameter types and
if they are optional or not:</p>

<pre><code>var ci:ClassInfo = ClassInfo.forClass(Point);
var con:Constructor = ci.getConstructor();
var params:Array = con.parameters;
trace("param count: " + params.length);
var param:Parameter = params[0] as Parameter;
trace("param 0 type: " + param.type.name);
trace("param 0 required: " + param.required);
param = params[1] as Parameter;
trace("param 1 type: " + param.type.name);
trace("param 1 required: " + param.required);
</code></pre>

<p class="paragraph">The output for the code above would be:</p>

<pre><code>param count: 2
param 0 type: Number
param 0 required: false
param 1 type: Number
param 1 required: false
</code></pre>

<p class="paragraph">Furthermore you can also use the <code>Constructor</code> class to reflectively 
create new instances:</p>

<pre><code>var ci:ClassInfo = ClassInfo.forClass(Point);
var con:Constructor = ci.getConstructor();
var instance:Point = con.newInstance([2, 5]);
trace(instance.x); // output: 2
trace(instance.y); // output: 5
</code></pre>

<p class="paragraph">When using <code>Constructor.newInstance</code> any necessary type conversion for the method parameters
will be done as described in <a href="reflection.php#conversion">19.3&nbsp;Automatic type conversion</a>.</p>

<p class="paragraph">Unfortunately there is a bug in Flash Player 9 that causes the type information for the
constructor parameters to get lost under certain circumstances, usually if you create a
<code>ClassInfo</code> instance for a class that has not been instantiated yet. If you run into
this bug it is usually sufficient to add a simple <code>new MyClass()</code> statement anywhere 
in your code before you start reflecting on that class. The bug is marked as "in progress"
in the <a href="http://bugs.adobe.com/jira/browse/FP-183" target="_blank">Adobe Jira</a>, so hopefully it will
be resolved for Player 10.</p>
<h2><a name="metadata"></a>19.7 Reflecting on metadata tags</h2>

<p class="paragraph">Introduced with version 1.1.0 the <code>Metadata</code> class allows to reflect on metadata tags
added to classes, properties or methods. The <code>ClassInfo</code>, <code>Constructor</code>, <code>Method</code>
and <code>Property</code> class now all extend <code>MetadataAware</code> directly or indirectly, so that you
can retrieve information on any metadata tags added to one of those elements. (Note that for the 
<code>Constructor</code> class the metadata feature was added for "forward compatibility", currently
the Flash Player ignores metadata tags placed on constructors).</p>

<p class="paragraph">There are two ways to reflect on metadata. The one described in this section just provides
untyped String-based access to tags and its attributes. The following section then explains how you
can register custom classes mapping to metadata tags to allow for type-safe reflection on metadata.</p>

<p class="paragraph">Consider this simple class:</p>

<pre><code>public class MyClass {

    [CustomMetadata(customAttribute="foo")]
    public function someMethod () : void {
        trace("someMethod invoked");    
    } 
    
}
</code></pre>   

<p class="paragraph">When you compile classes with custom metadata make sure that you add it to the
<code>-keep-as3-metadata</code> compiler option, as it will be ignored otherwise:</p>

<pre><code>mxmlc -keep-as3-metadata+=CustomMetadata,OtherTag1,OtherTag2 ... [other options]
</code></pre>

<p class="paragraph">If you use this option when compiling an SWC all projects that use that SWC
do not need to explicitly specify the metadata tags to keep as they will be included
automatically.</p>

<p class="paragraph">Now you can obtain information about such a tag at runtime:</p>

<pre><code>var ci:ClassInfo = ClassInfo.forClass(MyClass);
var m:Method = ci.getMethod("someMethod");
var tags:Array = m.getMetadata("CustomMetadata");
trace("number of metadata tags: " + tags.length);
var meta:Metadata = tags[0] as Metadata;
trace("customAttribute = " + meta.getArgument("customAttribute"));
</code></pre> 

<p class="paragraph">The output for the above code would be:</p>

<pre><code>number of metadata tags: 1
customAttribute = foo
</code></pre>

<p class="paragraph">Note that <code>getMetadata</code> always returns an Array because multiple tags of the same
type can be place on the same element. If no such tag exists for a particular element an empty
Array will be returned.</p>
<h2><a name="metadata_mapping"></a>19.8 Mapping classes to metadata tags</h2>

<p class="paragraph">While the API demonstrated in the previous section may be sufficient for simple use cases,
it would be more convenient to work with metadata in a type-safe way if you are doing more
than just simple lookups (like complex configuration tasks performed for custom metadata for example).</p>

<p class="paragraph">If you want to work with custom classes mapped to metadata tags you have to perform the following
tasks:</p>

<ul>
<li> Create a class with properties that correspond to the attributes of the metadata tag. </li>
<li> Add a <code>[Metadata]</code> tag to this custom class, optionally specifying the types on which this tag
is allowed to occur. </li>
<li> Optionally add a <code>[DefaultProperty]</code> tag to one of the properties of that class. </li>
<li> Register the class with <code>Metadata.registerMetadataClass</code>. </li>
<li> Add the metadata tag to the <code>-keep-as3-metadata</code> compiler option. </li>
</ul>

<p class="paragraph">We will walk you through all these steps with a concrete example. Consider the following
class:</p>

<pre><code>public class LoginController {

    [EventHandler(name="login", type="com.foo.LoginEvent")]
    public function handleLogin () : void {
        trace("handleLogin invoked");    
    } 
    
}
</code></pre>

<p class="paragraph">Let's assume you are building a framework that will interpret the <code>EventHandler</code> tag
and invoke the annotated method whenever such an Event occurs (in fact Parsley includes
metadata-driven configuration options like this). The first step would be to create a class
that represents this tag:</p>

<pre><code>[Metadata(name="EventHandler", types="method")]
public class EventHandlerMetadata {

    [DefaultProperty]
    public var name:String;
    
    public var type:ClassInfo;

}
</code></pre>

<p class="paragraph">As you see, the two properties correspond to the two attributes in the metadata tags. You are
not limited to working with Strings here, the Spicelib will automatically convert the attributes
to the property type, as long as there is a builtin Converter for that type. If you are working
with properties that the Spicelib cannot convert out-of-the-box, you can register your own
<code>Converter</code> instance as described in <a href="reflection.php#conversion">19.3&nbsp;Automatic type conversion</a>, but you should
rarely have the need to do so. In addition to the usual type conversion the metadata support
handles an additional use case that is quite common: You can define a comma-separated value
for an attribute when the property type is Array, in this case the Spicelib will split the
value accordingly (but without type conversions for the individual elements).</p>

<p class="paragraph">Above the class declaration you have to add the <code>[Metadata]</code> tag to declare
that this is a class that should be mapped to a custom metadata tag. The attribute specifies
the name of the tag (as we used it in the <code>LoginController</code> example class). If this
attribute is omitted it will use the non-qualified name of the class as the tag name.
The second attribute specifies on which types the metadata tag should be mapped to this class.
Permitted values are <code>class</code>, <code>constructor</code>, <code>method</code> and <code>property</code>
(but tags on the constructor are currently ignored by the Flex compilers, so this is included only
for eventual future use). If this attribute is omitted Spicelib will map the metadata tag for all
of these types. With this option you can for example map different classes for the same tag name,
in case you have a different set of attributes for annotated methods than for properties.</p> 

<p class="paragraph">Finally one of the two properties was defined as <code>[DefaultProperty]</code>. This means
that this property will be set whenever an attribute is specified without a key like 
in the following example:</p>

<pre><code>[EventHandler("login")]
</code></pre>

<p class="paragraph">Now that you have created the class that you want to map to metadata, you have to register
it like this:</p>

<pre><code>Metadata.registerMetadataClass(EventHandlerMetadata);
</code></pre>

<p class="paragraph">Make sure that you register the class before you reflect on a class that uses this tag
for the first time. Finally don't forget to add it to the <code>-keep-as3-metadata</code> compiler option.
Now you can start reflecting on those tags:</p>

<pre><code>var ci:ClassInfo = ClassInfo.forClass(LoginController);
var m:Method = ci.getMethod("handleLogin");
var tags:Array = m.getMetadata(EventHandlerMetadata);
trace("number of metadata tags: " + tags.length);
var meta:EventHandlerMetadata = tags[0] as EventHandlerMetadata;
trace("name = " + meta.name);
trace("type = " + meta.type.name);
</code></pre>

<p class="paragraph">The output for the above code would be:</p>

<pre><code>number of metadata tags: 1
name = login
type = com.foo.LoginEvent
</code></pre>

<p class="paragraph">Note that you no longer use Strings as keys in your <code>getMetadata</code> invocations,
you now use the class that represents the tag as the key (which is much better in terms of
type-safety).</p>

<p class="paragraph">If an error occurs while processing metadata tags (for example a type conversion that fails)
it will be silently swallowed. This is because an illegal metadata tag should not prevent you
from reflecting on the annotated method. We are considering adding a kind of optional "strict" mode
to a future release that would throw an Error in such a case or any other means to explicitly
validate tags.</p>
<h2><a name="appdomains"></a>19.9 Working with ApplicationDomains</h2>

<p class="paragraph">Finally, also introduced with version 1.1.0, Spicelib now supports ApplicationDomains.
In case you work with Flex Modules or other SWF files that are loaded in a separate
ApplicationDomain you can now tell the Spicelib Reflection API explicitly to use this
domain. For this purpose the three methods you can use to obtain a <code>ClassInfo</code>
instance have been modified to support an optional <code>ApplicationDomain</code> parameter:</p>

<pre><code>static function forName (name:String, domain:ApplicationDomain = null) : ClassInfo
		
static function forClass (clazz:Class, domain:ApplicationDomain = null) : ClassInfo

static function forInstance (instance:Object, domain:ApplicationDomain = null) : ClassInfo
</code></pre>

<p class="paragraph">Note that if you use a different domain you would have to specifiy it for all of these
methods, not only the one that takes a String argument. This is because even if you pass
an existing <code>Class</code> instance, the Spicelib might still need to know the domain to reflect
on dependent types, since it uses <code>describeType</code> internally which provides type
information for superclasses, implemented interfaces, property types and method parameter types
in the form of Strings. To convert these Strings to actual <code>Class</code> instances the 
specified domain will be used internally. Unfortunately AS3 does not have a similar construct
like Javas <code>getClassLoader</code> method which would make the <code>ApplicationDomain</code>
parameter obsolete for the second and third method.</p>

<p class="paragraph">If you omit the optional second parameter, the <code>ClassInfo</code> class will work
like in previous versions, simply using <code>ApplicationDomain.currentDomain</code>.</p>



<br/>
<br/>
<br/>

</div>

</body>
</html>
